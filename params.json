{"google":"","tagline":"ActiveRecord MultiTable inheritance simulated","note":"Don't delete this file! It's used internally to help with page regeneration.","body":"# Overview\r\n\r\nA `acts_as` relationship sets up a one-to-one connection with another model,\r\nsuch that declaring model inherits from other model (with separate database\r\ntabels). For example in a shop all products have common attributes (`name, price, image, ...`),\r\nwhile each type of them has their specific attributes, `pen` has `color`,\r\n`book` has `author` and `publisher` and so on.\r\n\r\nActiveRecord only supports singletable inheritance, but with single table inheritance\r\nnumber of attributes on parent model (product in this example) grow exponentially,\r\nand must of them will always stay `NULL`.\r\n\r\n# How It Works\r\n\r\n`acts_as` use a polymorphic `has_one`\r\nassociation to simulate a multi-table inheritance. For the shop example you'd\r\ndeclare the product as a `supermodel` and all types of it as `acts_as :product`\r\n(if you prefer you can use their aliases `is_a` and `is_a_superclass`)\r\n\r\n```ruby\r\nclass Product < ActiveRecord::Base\r\n  acts_as_superclass\r\n  attr_accessible :name, :price\r\nend\r\n\r\nclass Pen < ActiveRecord::Base\r\n  acts_as :product\r\n  attr_accessible :color\r\nend\r\n\r\nclass Book < ActiveRecord::Base\r\n  acts_as :product\r\nend\r\n```\r\n\r\nTo make this work, you need to declare both a foreign key column and a type column\r\nin the model that declares superclass. To do this you can set `:as_relation_superclass`\r\noption to `true` on `products` `create_table` (or pass it name of the association):\r\n\r\n```ruby\r\ncreate_table :products, :as_relation_superclass => true do |t|\r\n  # ...\r\nend\r\n```\r\n\r\nOr declare them as you do on a `polymorphic` `belongs_to` association, it this case\r\nyou must pass name to `acts_as` in `:as` option:\r\n\r\n````ruby\r\nchange_table :products do |t|\r\n  t.integer :producible_id\r\n  t.string  :producible_type\r\nend\r\n\r\nclass Pen < ActiveRecord::Base\r\n  acts_as :product, :as => :producible\r\nend\r\n```\r\n\r\nNow `Pen` and `Book` **act as** `Product`. This means that they inherit `Product`\r\n_attributes_, _associations_, _validations_ and _methods_. (things defined in `Product` model)\r\n\r\nTo see its functionality lets add some stuff to product:\r\n\r\n```ruby\r\nclass Product\r\n  validates_presence_of :name, :price\r\n\r\n  def to_s\r\n    \"#{name} $#{price}\"\r\n  end\r\nend\r\n```\r\n\r\nnow we can to things like this:\r\n\r\n```\r\n> Pen.create :name => \"Nice Pen\", :price => 1.3, :color => \"Red\"\r\n> Pen.where \"name = ?\", \"Some Pen\"\r\n> pen = Pen.new\r\n> pen.valid? \r\n  => false\r\n> pen.errors.keys\r\n  => [:name, :price]\r\n> Pen.first.to_s\r\n  => \"Nice Pen $1.3\"\r\n```\r\n\r\nWhen you declare an `acts_as` relation, the declaring class automatically gains parent\r\nmethods (includeing accessors) so you can access them directly.\r\n\r\nOn the other hand you can always access a specific object from its parent by calling `specific` method on it:\r\n\r\n```\r\n> Product.first.specific # will return a specific product, a pen for example\r\n```\r\n\r\n# Options\r\nThe `acts_as` relation support these options:\r\n\r\n* `:as`\r\n* `:auto_join`\r\n* `:class_name`\r\n* `:conditions`\r\n* `:dependent`\r\n* `:include`\r\n\r\nwhen `:auto_join` option set to `true` (which is by default), every query on child\r\nwill automatically joins the parent table. For example:\r\n\r\n```\r\n> Pen.where(\"name = ?\", \"somename\")\r\n```\r\n\r\nwill result in the following SQL:\r\n\r\n```\r\nSELECT \"pens\".* FROM \"pens\" INNER JOIN \"products\" ON \"products\".\"as_product_id\" = \"pens\".\"id\"  AND\"products\".\"as_product_type\" = 'Pen' WHERE (name = 'somename')\r\n```\r\n\r\nAll other options are same as `has_one` options.\r\n","name":"Acts as relation"}